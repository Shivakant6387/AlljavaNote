1)why java is not 100% object-oriented ? 
ans Because of Primitive data types namely
	boolean , byte ,char,int ,floot,double,long,short
To make them oo we have wrapper classes which actually "wrap" the primitive data type
 into an object of that class.
2) why pointers are not used in java ?
ans Because :
	1)They are unsafe .
	2)Increases the complexity of the program and since java is known for its 
	 simplicity of code ,adding the concept of pointers will be contradicting .
	3)Since JVM is responsible for implicit memory allocation, thus in order to 
	 avoid direct access to memory by the user ,pointers are discouraged in java 
3) what is JIT compiler in java ?
ans java source code into jdk(javac.ece)into Byte codes(jre interpreter +jit compiler)into Machine codes
or
The Just-In-Time (JIT) compiler is a component of the Java™ Runtime Environment that improves the performance of Java applications at run time. Java programs consists of classes, which contain platform-neutral bytecodes that can be interpreted by a JVM on many different computer
4) why String is immutable in java ?
ans The String is immutable in Java because of the security, synchronization and concurrency, caching, and class loading.
>String pool requires string to be immutable otherwise shared reference can be changed from anywhere.

>security because string is shared on different area like file system,networking connection ect
>having immutable string allows you to be secure and safe because no one can change reference of string once it gets created.
5) what is a maker interface ?
ans 
It is an empty interface (no field or methods). Examples of marker interface are Serializable, Cloneable and Remote interface. All these interfaces are empty interfaces. 
or
A marker interface can be defined as interface having no data member and member functions.In simpler terms an empty interface is called the marker interface
Example Serializable,Cloneable
6) can you override a private or static method in java ?
ANS:-No, we cannot override static methods because method overriding is based on dynamic binding at runtime and the static methods are bonded using static binding at compile time. So, we cannot override static methods.
The calling of method depends upon the type of object that calls the static method
7)Does "finally " always execute in java?
ans :-Java finally block is always executed whether an exception is handled or not. Therefore, it contains all the necessary statements that need to be printed regardless of the exception occurs or not.

Note: If you don't handle the exception, before terminating the program, JVM executes finally block (if any).

8)Why use Java finally block?
finally block in Java can be used to put "cleanup" code such as closing a file, closing connection, etc.
The important statements to be printed can be placed in the finally block.
The finally block follows the try-catch block.

8)what methods Does the Object class have?
Ans:
9)How can you make a class immutable?
Ans:
There are many immutable classes like String, Boolean, Byte, Short, Integer, Long, Float, Double etc. In short, all the wrapper classes and String class is immutable. We can also create immutable class by creating final class that have final data members as the example given below:
 demo
public final class Employee  
{    
final String pancardNumber;    
public Employee(String pancardNumber)  
{    
this.pancardNumber=pancardNumber;    
}  
public String getPancardNumber(){    
return pancardNumber;    
}    
}    
public class ImmutableDemo  
{  
public static void main(String ar[])  
{  
Employee e = new Employee("ABC123");  
String s1 = e.getPancardNumber();  
System.out.println("Pancard Number: " + s1);  
}  
}  
10)what is singleton class in java and how can we make a class singleton?
ans Singleton class is a class whose only one instance can be created at any given time , in one JVM

11)Wrapper classes in Java
ans:-The wrapper class in Java provides the mechanism to convert primitive into object and object into primitive.
12)what is the need for oops?
13)what are the main features of oops?
14)what is inheritance
15)what is Encapsulation
16)what is polymorphism
17)what is Abstraction
18)what is method
19)what is constructor
20)what are some advantages of using oops
21)why is oops so popular?
22)what is class
23)what is an object
24)what is copy constructor
25)Are there any limitations of interface
26)what  are the various types of inheritance
27)what is single inheritance 
28)multiple inheritances
29)Multi-level inheritance 
30)Hiearchical inheritance
31)Hybrid inheritance
32)different hiearchical and multi-level
Q1. How can you handle exceptions in Java?
Ans:-The try-catch is the simplest method of handling exceptions. Put the code you want to run in the try block, and any Java exceptions that the code throws are caught by one or more catch blocks.
=>This method will catch any type of Java exceptions that get thrown. This is the simplest mechanism for handling exceptions.

Q2. What is the difference between exception and error in Java?
Ans:-

Sr. No.
Key
Error
Exception
1
Type 
Classified as an unchecked type 
Classified as checked and unchecked 
2
Package 
It belongs to java.lang.error 
It belongs to java.lang.Exception 
3
Recoverable/ Irrecoverable
It is irrecoverable
It is recoverable
4 
 
It can't be occur at compile time 
It can occur at run time compile time both 
5
Example
OutOfMemoryError ,IOError 
NullPointerException , SqlException 

Q3. Why do we need exception handling in Java?
=>Java exception handling is important because it helps maintain the normal, desired flow of the program even when unexpected events occur. 
=>If Java exceptions are not handled, programs may crash or requests may fail.
=>The Exception Handling in Java is one of the powerful mechanism to handle the runtime errors so that the normal flow of the application can be maintained.


4. Name the different types of exceptions in Java
Ans:- There are mainly two types of exceptions in Java as follows: Checked exception. Unchecked exception
exception is an event that occurs during the execution of a program and disrupts the normal flow of the program's instructions. Bugs or errors that we don't want and restrict our program's normal execution of code are referred to as exceptions. In this section, we will focus on the types of exceptions in Java and the differences between the two.
Q5. Can we just use try instead of finally and catch blocks?
Ans:- Yes, It is possible to have a try block without a catch block by using a final block.


Can we throw an exception explicitly or manually?
    1. Describe the use of the throw keyword.
    2. Ans:-The Java throw keyword is used to throw an exception explicitly.
    3. We specify the exception object which is to be thrown. The Exception has some message with it that provides the error description. These exceptions may be related to user inputs, server, etc.
    4. Note: If we throw unchecked exception from a method, it is must to handle the exception or declare in throws clause.
Note: Every subclass of Error and RuntimeException is an unchecked exception in Java. A checked exception is everything else under the Throwable class.
																																																					
    5.  should we clean up activities such as I/O resources in the finally block?
       Ans:
    6. Describe OutofMemoryError in exception handling.
       Ans:
    7. What is the error of  ClassCastException? 
       Ans:
    8. Is there any difference between throw and throws in exception handling in Java?
       ans
    9. When should we use the printStackTrace() method?
       Ans:
    10. Provide me with some examples of unchecked exceptions.
       Ans:
    11. Is it illegal to keep an empty catch?
       Ans:
    12. What are the advantages of using exception handling in Java?
       Ans:
    13. Can checked exceptions occur at compiled time?
       Ans:
    14. What happens if a runtime exception occurs?
       Ans:
    15. Describe unreachable catch block error in Java.
       Ans:
    16. In which situation will you not be able to execute the finally block?
       Ans:
    17. Is it possible to throw a statement inside a static block?
	Ans:
	What is multithreading in java 
1. What are the benefits of using Multithreading?
There are various benefits of multithreading as given below:
    • Allow the program to run continuously even if a part of it is blocked. 
    • Improve performance as compared to traditional parallel programs that use multiple processes. 
    • Allows to write effective programs that utilize maximum CPU time
    • Improves the responsiveness of complex applications or programs. 
    • Increase use of CPU resources and reduce costs of maintenance. 
    • Saves time and parallelism tasks. 
    • If an exception occurs in a single thread, it will not affect other threads as threads are independent. 
    • Less resource-intensive than executing multiple processes at the same time. 
2. What is Thread in Java?
Threads are basically the lightweight and smallest unit of processing that can be managed independently by a scheduler. Threads are referred to as parts of a process that simply let a program execute efficiently with other parts or threads of the process at the same time. Using threads, one can perform complicated tasks in the easiest way. It is considered the simplest way to take advantage of multiple CPUs available in a machine. They share the common address space and are independent of each other. 
3. What are the two ways of implementing thread in Java?
There are basically two ways of implementing thread in java as given below: 
    • Extending the Thread class
Example:
class MultithreadingDemo extends Thread 
{   
  public void run() 
 {   
     System.out.println("My thread is in running state.");    
 } 
  public static void main(String args[]) 
 {   
    MultithreadingDemo obj=new MultithreadingDemo();  
        obj.start();  
  }  
} 
Output:
My thread is in running state.
    • Implementing Runnable interface in Java
Example:  
class MultithreadingDemo implements Runnable 
{  
   public void run() 
 {  
      System.out.println("My thread is in running state.");  
  }  
    public static void main(String args[]) 
 {  
      MultithreadingDemo obj=new MultithreadingDemo();   
      Threadtobj =new Thread(obj);       tobj.start();  
 }   
} 
Output: 
My thread is in running state. 
You can download a PDF version of Multithreading Interview Questions.
Download PDF


4. What's the difference between thread and process?
Thread: It simply refers to the smallest units of the particular process. It has the ability to execute different parts (referred to as thread) of the program at the same time.  

Process: It simply refers to a program that is in execution i.e., an active program. A process can be handled using PCB (Process Control Block). 

Thread
Process
It is a subset of a subunit of a process.
It is a program in execution containing multiple threads.
In this, inter-thread communication is faster, less expensive, easy and efficient because threads share the same memory address of the process they belong to. 
In this, inter-process communication is slower, expensive, and complex because each process has different memory space or address.,
These are easier to create, lightweight, and have less overhead. 
These are difficult to create, heavyweight, and have more overhead.
It requires less time for creation, termination, and context switching.
It requires more time for creation, termination, and context switching.
Processes with multiple threads use fewer resources.
Processes without threads use more resources.
Threads are parts of a process, so they are dependent on each other but each thread executes independently.
Processes are independent of each other.
There is a need for synchronization in threads to avoid unexpected scenarios or problems.
There is no need for synchronization in each process.
They share data and information with each other. 
They do not share data with each other. 







ubset of a subunit of a process.

In this, inter-thread communication is faster, less expensive, easy and efficient because threads share the same memory address of the process they belong to. 

These are easier to create, lightweight, and hve less overhead. 

It requires less time for creation, termination, and context switching.

Processes with multiple threads use fewer resources.

Threads are parts of a process, so they are dependent on each other but each thread executes independently.

There is a need for synchronization in threads to avoid unexpected scenarios or problems.

They share data and information with each other. 

5. What’s the difference between class lock and object lock?
Class Lock: In java, each and every class has a unique lock usually referred to as a class level lock. These locks are achieved using the keyword ‘static synchronized’ and can be used to make static data thread-safe. It is generally used when one wants to prevent multiple threads from entering a synchronized block. 

Example:  
public class ClassLevelLockExample  
{    
  public void classLevelLockMethod()  
 {       
     synchronized (ClassLevelLockExample.class)  
       {         
            //DO your stuff here       
       }    
 } 
} 
Object Lock: In java, each and every object has a unique lock usually referred to as an object-level lock. These locks are achieved using the keyword ‘synchronized’ and can be used to protect non-static data. It is generally used when one wants to synchronize a non-static method or block so that only the thread will be able to execute the code block on a given instance of the class.  

Example:  
public class ObjectLevelLockExample  
{    
  public void objectLevelLockMethod()  
 {   
     synchronized (this)  
       {     
            //DO your stuff here   
       } 
 }
} 
6. What's the difference between User thread and Daemon thread?
User and Daemon are basically two types of thread used in Java by using a ‘Thread Class’.  

User Thread (Non-Daemon Thread): In Java, user threads have a specific life cycle and its life is independent of any other thread. JVM (Java Virtual Machine) waits for any of the user threads to complete its tasks before terminating it. When user threads are finished, JVM terminates the whole program along with associated daemon threads. 

Daemon Thread: In Java, daemon threads are basically referred to as a service provider that provides services and support to user threads. There are basically two methods available in thread class for daemon thread: setDaemon() and isDaemon(). 

User Thread vs Daemon Thread
User Thread
Daemon Thread 
JVM waits for user threads to finish their tasks before termination. 
JVM does not wait for daemon threads to finish their tasks before termination.
These threads are normally created by the user for executing tasks concurrently. 
These threads are normally created by JVM.
They are used for critical tasks or core work of an application. 
They are not used for any critical tasks but to do some supporting tasks.
These threads are referred to as high-priority tasks, therefore are required for running in the foreground. 
These threads are referred to as low priority threads, therefore are especially required for supporting background tasks like garbage collection, releasing memory of unused objects, etc. 
7. How can we create daemon threads?
We can create daemon threads in java using the thread class setDaemon(true). It is used to mark the current thread as daemon thread or user thread. isDaemon() method is generally used to check whether the current thread is daemon or not. If the thread is a daemon, it will return true otherwise it returns false.  
Example:   
Program to illustrate the use of setDaemon() and isDaemon() method. 
public class DaemonThread extends Thread 
{ 
   public DaemonThread(String name){ 
       super(name); 
   } 
   public void run() 
   {  
       // Checking whether the thread is Daemon or not 
       if(Thread.currentThread().isDaemon()) 
       {  
           System.out.println(getName() + " is Daemon thread");  
       }    
       else 
       {  
           System.out.println(getName() + " is User thread");  
       }  
   }   
   public static void main(String[] args) 
   {  
       DaemonThread t1 = new DaemonThread("t1"); 
       DaemonThread t2 = new DaemonThread("t2"); 
       DaemonThread t3 = new DaemonThread("t3");  
       // Setting user thread t1 to Daemon 
       t1.setDaemon(true);       
       // starting first 2 threads  
       t1.start();  
       t2.start();   
       // Setting user thread t3 to Daemon 
       t3.setDaemon(true);  
       t3.start();         
   }  
} 
Output:  
t1 is Daemon thread 
t3 is Daemon thread 
t2 is User thread 
But one can only call the setDaemon() method before start() method otherwise it will definitely throw IllegalThreadStateException as shown below:   
public class DaemonThread extends Thread 
{ 
   public void run() 
   { 
       System.out.println("Thread name: " + Thread.currentThread().getName()); 
       System.out.println("Check if its DaemonThread: "  
                       + Thread.currentThread().isDaemon()); 
   } 
   public static void main(String[] args) 
   { 
       DaemonThread t1 = new DaemonThread(); 
       DaemonThread t2 = new DaemonThread(); 
       t1.start();         
       // Exception as the thread is already started 
       t1.setDaemon(true); 
       t2.start(); 
   } 
} 
Output:  
Thread name: Thread-0 
Check if its DaemonThread: false 
8. What are the wait() and sleep() methods?
wait(): As the name suggests, it is a non-static method that causes the current thread to wait and go to sleep until some other threads call the notify () or notifyAll() method for the object’s monitor (lock). It simply releases the lock and is mostly used for inter-thread communication. It is defined in the object class, and should only be called from a synchronized context. 
Example:  
synchronized(monitor) 
{ 
monitor.wait();       Here Lock Is Released by Current Thread  
} 
sleep(): As the name suggests, it is a static method that pauses or stops the execution of the current thread for some specified period. It doesn’t release the lock while waiting and is mostly used to introduce pause on execution. It is defined in thread class, and no need to call from a synchronized context.  
Example:  
synchronized(monitor) 
{ 
Thread.sleep(1000);     Here Lock Is Held by The Current Thread 
//after 1000 milliseconds, the current thread will wake up, or after we call that is interrupt() method 
} 
9. What’s the difference between notify() and notifyAll()?
notify(): It sends a notification and wakes up only a single thread instead of multiple threads that are waiting on the object’s monitor.

notifyAll(): It sends notifications and wakes up all threads and allows them to compete for the object's monitor instead of a single thread. 

10. Why wait(), notify(), and notifyAll() methods are present in Object class?
We know that every object has a monitor that allows the thread to hold a lock on the object. But the thread class doesn't contain any monitors. Thread usually waits for the object’s monitor (lock) by calling the wait() method on an object, and notify other threads that are waiting for the same lock using notify() or notifyAll() method.  Therefore, these three methods are called on objects only and allow all threads to communicate with each that are created on that object.
11. What is Runnable and Callable Interface? Write the difference between them.
Both the interfaces are generally used to encapsulate tasks that are needed to be executed by another thread. But there are some differences between them as given below: 

Running Interface: This interface is basically available in Java right from the beginning. It is simply used to execute code on a concurrent thread.  
Callable Interface: This interface is basically a new one that was introduced as a part of the concurrency package. It addresses the limitation of runnable interfaces along with some major changes like generics, enum, static imports, variable argument method, etc. It uses generics to define the return type of object.   
public interface Runnable  
{   
  public abstract void run(); 
}  
public interface Callable<V>  
{    
V call() throws Exception;  
} 
Runnable Interface vs Callable Interface
Runnable Interface
Callable Interface 
It does not return any result and therefore, cannot throw a checked exception. 
It returns a result and therefore, can throw an exception.
It cannot be passed to invokeAll method. 
It can be passed to invokeAll method.
It was introduced in JDK 1.0.
It was introduced in JDK 5.0, so one cannot use it before Java 5. 
It simply belongs to Java.lang.
It simply belongs to java.util.concurrent. 
It uses the run() method to define a task.
It uses the call() method to define a task. 
To use this interface, one needs to override the run() method. 
To use this interface, one needs to override the call() method.
12. What is the start() and run() method of Thread class?
start(): In simple words, the start() method is used to start or begin the execution of a newly created thread. When the start() method is called, a new thread is created and this newly created thread executes the task that is kept in the run() method. One can call the start() method only once.  

run(): In simple words, the run() method is used to start or begin the execution of the same thread. When the run() method is called, no new thread is created as in the case of the start() method. This method is executed by the current thread. One can call the run() method multiple times. 
13. Explain thread pool?
A Thread pool is simply a collection of pre-initialized or worker threads at the start-up that can be used to execute tasks and put back in the pool when completed. It is referred to as pool threads in which a group of fixed-size threads is created.  By reducing the number of application threads and managing their lifecycle, one can mitigate the issue of performance using a thread pool. Using threads, performance can be enhanced and better system stability can occur. To create the thread pools, java.util.concurrent.Executors class usually provides factory methods.
14. What’s the purpose of the join() method?
join() method is generally used to pause the execution of a current thread unless and until the specified thread on which join is called is dead or completed. To stop a thread from running until another thread gets ended, this method can be used. It joins the start of a thread execution to the end of another thread’s execution. It is considered the final method of a thread class.
15. What do you mean by garbage collection?
Garbage collection is basically a process of managing memory automatically. It uses several GC algorithms among which the popular one includes Mark and Sweep. The process includes three phases i.e., marking, deletion, and compaction/copying. In simple words, a garbage collector finds objects that are no longer required by the program and then delete or remove these unused objects to free up the memory space.
16. Explain the meaning of the deadlock and when it can occur?
Deadlock, as the name suggests, is a situation where multiple threads are blocked forever. It generally occurs when multiple threads hold locks on different resources and are waiting for other resources to complete their task.

The above diagram shows a deadlock situation where two threads are blocked forever.  Thread 1 is holding Object 1 but needs object 2 to complete processing whereas Thread 2 is holding Object 2 but needs object 1 first. In such conditions, both of them will hold lock forever and will never complete tasks.
17. Explain volatile variables in Java?
A volatile variable is basically a keyword that is used to ensure and address the visibility of changes to variables in multithreaded programming. This keyword cannot be used with classes and methods, instead can be used with variables. It is simply used to achieve thread-safety. If you mark any variable as volatile, then all the threads can read its value directly from the main memory rather than CPU cache, so that each thread can get an updated value of the variable.
18. How do threads communicate with each other?
Threads can communicate using three methods i.e., wait(), notify(), and notifyAll().
19. Can two threads execute two methods (static and non-static concurrently)?
Yes, it is possible. If both the threads acquire locks on different objects, then they can execute concurrently without any problem.
20. What is the purpose of the finalize() method?
Finalize() method is basically a method of Object class specially used to perform cleanup operations on unmanaged resources just before garbage collection. It is not at all intended to be called a normal method. After the complete execution of finalize() method, the object gets destroyed automatically.
Multithreading Interview Questions in Java for Experienced
21. What is the synchronization process? Why use it?
Synchronization is basically a process in java that enables a simple strategy for avoiding thread interference and memory consistency errors. This process makes sure that resource will be only used one thread at a time when one thread tries to access a shared resource. It can be achieved in three different ways as given below: 
    • By the synchronized method
    • By synchronized block
    • By static synchronization
Syntax:  
synchronized (object) 
{        
   //statement to be synchronized 
} 
22. What is synchronized method and synchronized block? Which one should be preferred?
Synchronized Method: In this method, the thread acquires a lock on the object when they enter the synchronized method and releases the lock either normally or by throwing an exception when they leave the method.  No other thread can use the whole method unless and until the current thread finishes its execution and release the lock. It can be used when one wants to lock on the entire functionality of a particular method. 

Synchronized Block: In this method, the thread acquires a lock on the object between parentheses after the synchronized keyword, and releases the lock when they leave the block. No other thread can acquire a lock on the locked object unless and until the synchronized block exists. It can be used when one wants to keep other parts of the programs accessible to other threads.
 
Synchronized blocks should be preferred more as it boosts the performance of a particular program. It only locks a certain part of the program (critical section) rather than the entire method and therefore leads to less contention.
23. What is thread starvation?
Thread starvation is basically a situation or condition where a thread won’t be able to have regular access to shared resources and therefore is unable to proceed or make progress. This is because other threads have high priority and occupy the resources for too long. This usually happens with low-priority threads that do not get CPU for its execution to carry on. 

24. What is Livelock? What happens when it occurs?
Similar to deadlock, livelock is also another concurrency problem. In this case, the state of threads changes between one another without making any progress. Threads are not blocked but their execution is stopped due to the unavailability of resources.
25. What is BlockingQueue?
BlockingQueue basically represents a queue that is thread-safe. Producer thread inserts resource/element into the queue using put() method unless it gets full and consumer thread takes resources from the queue using take() method until it gets empty. But if a thread tries to dequeue from an empty queue, then a particular thread will be blocked until some other thread inserts an item into the queue, or if a thread tries to insert an item into a queue that is already full, then a particular thread will be blocked until some threads take away an item from the queue. 

Example: 
package org.arpit.java2blog; 
 
import java.util.concurrent.ArrayBlockingQueue; 
import java.util.concurrent.BlockingQueue; 
 
public class BlockingQueuePCExample { 
 
   public static void main(String[] args) { 
 
       BlockingQueue<String> queue=new ArrayBlockingQueue<>(5); 
       Producer producer=new Producer(queue); 
       Consumer consumer=new Consumer(queue); 
       Thread producerThread = new Thread(producer); 
       Thread consumerThread = new Thread(consumer); 
 
       producerThread.start(); 
       consumerThread.start(); 
 
   } 
 
   static class Producer implements Runnable { 
 
       BlockingQueue<String> queue=null; 
 
       public Producer(BlockingQueue queue) { 
           super(); 
           this.queue = queue; 
       } 
 
       @Override 
       public void run() { 
 
               try { 
                   System.out.println("Producing element 1"); 
                   queue.put("Element 1"); 
                   Thread.sleep(1000); 
                   System.out.println("Producing element 2"); 
                   queue.put("Element 2"); 
                   Thread.sleep(1000); 
                   System.out.println("Producing element 3"); 
                   queue.put("Element 3"); 
               } catch (InterruptedException e) { 
 
                   e.printStackTrace(); 
               } 
       } 
   } 
 
   static class Consumer implements Runnable { 
 
       BlockingQueue<String> queue=null; 
 
       public Consumer(BlockingQueue queue) { 
           super(); 
           this.queue = queue; 
       } 
 
       @Override 
       public void run() { 
 
           while(true) 
           { 
               try { 
                   System.out.println("Consumed "+queue.take()); 
               } catch (InterruptedException e) { 
                   e.printStackTrace(); 
               } 
           } 
       } 
 
   } 
} 
Output: 
Producing element 1 
Consumed Element 1 
Producing element 2 
Consumed Element 2 
Producing element 3 
Consumed Element 3
26. Can you start a thread twice?
No, it's not at all possible to restart a thread once a thread gets started and completes its execution. Thread only runs once and if you try to run it for a second time, then it will throw a runtime exception i.e., java.lang.IllegalThreadStateException. 

Example: 
public class TestThreadTwice1 extends Thread{   
public void run(){   
System.out.println(" thread is executing now........");   
}   
public static void main(String args[]){   
TestThreadTwice1 t1=new TestThreadTwice1();   
t1.start();   
t1.start();   
}   
}   
Output:
thread is executing now........ 
Exception in thread "main" java.lang.IllegalThreadStateException  
27. Explain context switching.
Context switching is basically an important feature of multithreading. It is referred to as switching of CPU from one thread or process to another one. It allows multiple processes to share the same CPU. In context switching, the state of thread or process is stored so that the execution of the thread can be resumed later if required. 
28. What is CyclicBarrier and CountDownLatch?
CyclicBarrier and CountDownLatch, both are required for managing multithreaded programming. But there is some difference between them as given below: 
CyclicBarrier: It is a tool to synchronize threads processing using some algorithm. It enables a set of threads to wait for each other till they reach a common execution point or common barrier points, and then let them further continue execution. One can reuse the same CyclicBarrier even if the barrier is broken by setting it. 
CountDownLatch: It is a tool that enables main threads to wait until mandatory operations are performed and completed by other threads. In simple words, it makes sure that a thread waits until the execution in another thread completes before it starts its execution. One cannot reuse the same CountDownLatch once the count reaches 0. 

29. What do you mean by inter-thread communication?
Inter-thread communication, as the name suggests, is a process or mechanism using which multiple threads can communicate with each other. It is especially used to avoid thread polling in java and can be obtained using wait(), notify(), and notifyAll() methods. 
30. What is Thread Scheduler and Time Slicing?
Thread Scheduler: It is a component of JVM that is used to decide which thread will execute next if multiple threads are waiting to get the chance of execution. By looking at the priority assigned to each thread that is READY, the thread scheduler selects the next run to execute. To schedule the threads, it mainly uses two mechanisms: Preemptive Scheduling and Time slicing scheduling.  

Time Slicing: It is especially used to divide CPU time and allocate them to active threads. In this, each thread will get a predefined slice of time to execute. When the time expires, a particular thread has to wait till other threads get their chances to use their time in a round-robin fashion. Every running thread will get executed for a fixed time period. 
31. What is a shutdown hook?
A shutdown hook is simply a thread that is invoked implicitly before JVM shuts down. It is one of the most important features of JVM because it provides the capacity to do resource cleanup or save application state JVM shuts down.  By calling the halt(int) method of the Runtime class, the shutdown hook can be stopped. Using the following method, one can add a shutdown hook. 
public void addShutdownHook(Thread hook){}     
Runtime r=Runtime.getRuntime();   
r.addShutdownHook(new MyThread());
32. What is busy spinning?
Busy Spinning, also known as Busy-waiting, is a technique in which one thread waits for some condition to happen, without calling wait or sleep methods and releasing the CPU. In this condition, one can pause a thread by making it run an empty loop for a certain time period, and it does not even give CPY control. Therefore, it is used to preserve CPU caches and avoid the cost of rebuilding cache.
33. What is ConcurrentHashMap and Hashtable? In java, why is ConcurrentHashMap considered faster than Hashtable?
ConcurrentHashMap: It was introduced in Java 1.5 to store data using multiple buckets. As the name suggests, it allows concurrent read and writes operations to the map. It only locks a certain portion of the map while doing iteration to provide thread safety so that other readers can still have access to the map without waiting for iteration to complete.  

Hashtable: It is a thread-safe legacy class that was introduced in old versions of java to store key or value pairs using a hash table.  It does not provide any lock-free read, unlike ConcurrentHashMap. It just locks the entire map while doing iteration. 

ConcurrentHashMap and Hashtable, both are thread-safe but ConcurrentHashMap generally avoids read locks and improves performance, unlike Hashtable. ConcurrentHashMap also provides lock-free reads, unlike Hashtable. Therefore, ConcurrentHashMap is considered faster than Hashtable especially when the number of readers is more as compared to the number of writers. 
34. Explain thread priority.
Thread priority simply means that threads with the highest priority will get a chance for execution prior to low-priority threads. One can specify the priority but it's not necessary that the highest priority thread will get executed before the lower-priority thread. Thread scheduler assigns processor to thread on the basis of thread priority. The range of priority changes between 1-10 from lowest priority to highest priority. 

35. What do you mean by the ThreadLocal variable in Java?
ThreadLocal variables are special kinds of variables created and provided by the Java ThreadLocal class. These variables are only allowed to be read and written by the same thread. Two threads cannot be able to see each other’s ThreadLocal variable, so even if they will execute the same code, then there won't be any race condition and the code will be thread-safe.  

Example:  
public class ThreadLocalExp   
{   
     public static class MyRunnable implements Runnable    
   {   
       private ThreadLocal<Integer> threadLocal =   
              new ThreadLocal<Integer>();   
      @Override   
       public void run() {   
           threadLocal.set( (int) (Math.random() * 50D) );   
           try    
           {   
               Thread.sleep(1000);   
           } catch (InterruptedException e) {   
           }   
           System.out.println(threadLocal.get());   
       }   
   }   
   public static void main(String[] args)    
   {   
       MyRunnable runnableInstance = new MyRunnable();    
       Thread t1 = new Thread(runnableInstance);   
       Thread t2 = new Thread(runnableInstance);   
      // this will call run() method    
       t1.start();   
       t2.start();   
   }   
} 
Output: 
10 
33 
10 33 
36. What is semaphore?
Semaphore is regarded as a thread synchronization construct that is usually required to control and manage the access to the shared resource using counters. It simply sets the limit of the thread. The semaphore class is defined within the package java.util.concurrent and can be used to send signals between threads to avoid missed signals or to guard critical sections. It can also be used to implement resource pools or bounded collection.
37. Explain Thread Group. Why should we not use it?
ThreadGroup is a class that is used to create multiple groups of threads in a single object. This group of threads is present in the form of three structures in which every thread group has a parent except the initial thread. Thread groups can contain other thread groups also. A thread is only allowed to have access to information about its own thread group, not other thread groups. 

Previously in the old version of Java, the only functionality that did not work without a thread group was uncaughtException( Thread t, Throwable e). But now in Java 5 versions, there is Thread.setUncaughtExceptionHandler(UncaughtExceptionHandler). So now even that works without thread groups and therefore, there is no need to use thread groups.  
t1.setUncaughtExceptionHandler(new UncaughtExceptionHandler() 
{ 
@Override  
public void uncaughtException(Thread t, Throwable e)  
{  
System.out.println("exception occured:"+e.getMessage()); 
}  
}; 
38. What is the ExecutorService interface?
ExecutorService interface is basically a sub-interface of Executor interface with some additional methods or features that help in managing and controlling the execution of threads. It enables us to execute tasks asynchronously on threads.

Example: 
import java.util.concurrent.ExecutorService;   
import java.util.concurrent.Executors;   



notifyAll(): It sends notifications and wakes up all threads and allows them to compete for the object's monitor instead of a single thread. 

10. Why wait(), notify(), and notifyAll() methods are present in Object class?
We know that every object has a monitor that allows the thread to hold a lock on the object. But the thread class doesn't contain any monitors. Thread usually waits for the object’s monitor (lock) by calling the wait() method on an object, and notify other threads that are waiting for the same lock using notify() or notifyAll() method.  Therefore, these three methods are called on objects only and allow all threads to communicate with each that are created on that object.
11. What is Runnable and Callable Interface? Write the difference between them.
Both the interfaces are generally used to encapsulate tasks that are needed to be executed by another thread. But there are some differences between them as given below: 

Running Interface: This interface is basically available in Java right from the beginning. It is simply used to execute code on a concurrent thread.  
Callable Interface: This interface is basically a new one that was introduced as a part of the concurrency package. It addresses the limitation of runnable interfaces along with some major changes like generics, enum, static imports, variable argument method, etc. It uses generics to define the return type of object.   
public interface Runnable  
{   
  public abstract void run(); 
}  
public interface Callable<V>  
{    
V call() throws Exception;  
} 
Runnable Interface vs Callable Interface
Runnable Interface
Callable Interface 
It does not return any result and therefore, cannot throw a checked exception. 
It returns a result and therefore, can throw an exception.
It cannot be passed to invokeAll method. 
It can be passed to invokeAll method.
It was introduced in JDK 1.0.
It was introduced in JDK 5.0, so one cannot use it before Java 5. 
It simply belongs to Java.lang.
It simply belongs to java.util.concurrent. 
It uses the run() method to define a task.
It uses the call() method to define a task. 
To use this interface, one needs to override the run() method. 
To use this interface, one needs to override the call() method.
12. What is the start() and run() method of Thread class?
start(): In simple words, the start() method is used to start or begin the execution of a newly created thread. When the start() method is called, a new thread is created and this newly created thread executes the task that is kept in the run() method. One can call the start() method only once.  

run(): In simple words, the run() method is used to start or begin the execution of the same thread. When the run() method is called, no new thread is created as in the case of the start() method. This method is executed by the current thread. One can call the run() method multiple times. 
13. Explain thread pool?
A Thread pool is simply a collection of pre-initialized or worker threads at the start-up that can be used to execute tasks and put back in the pool when completed. It is referred to as pool threads in which a group of fixed-size threads is created.  By reducing the number of application threads and managing their lifecycle, one can mitigate the issue of performance using a thread pool. Using threads, performance can be enhanced and better system stability can occur. To create the thread pools, java.util.concurrent.Executors class usually provides factory methods.
14. What’s the purpose of the join() method?
join() method is generally used to pause the execution of a current thread unless and until the specified thread on which join is called is dead or completed. To stop a thread from running until another thread gets ended, this method can be used. It joins the start of a thread execution to the end of another thread’s execution. It is considered the final method of a thread class.
15. What do you mean by garbage collection?
Garbage collection is basically a process of managing memory automatically. It uses several GC algorithms among which the popular one includes Mark and Sweep. The process includes three phases i.e., marking, deletion, and compaction/copying. In simple words, a garbage collector finds objects that are no longer required by the program and then delete or remove these unused objects to free up the memory space.
16. Explain the meaning of the deadlock and when it can occur?
Deadlock, as the name suggests, is a situation where multiple threads are blocked forever. It generally occurs when multiple threads hold locks on different resources and are waiting for other resources to complete their task.

The above diagram shows a deadlock situation where two threads are blocked forever.  Thread 1 is holding Object 1 but needs object 2 to complete processing whereas Thread 2 is holding Object 2 but needs object 1 first. In such conditions, both of them will hold lock forever and will never complete tasks.
17. Explain volatile variables in Java?
A volatile variable is basically a keyword that is used to ensure and address the visibility of changes to variables in multithreaded programming. This keyword cannot be used with classes and methods, instead can be used with variables. It is simply used to achieve thread-safety. If you mark any variable as volatile, then all the threads can read its value directly from the main memory rather than CPU cache, so that each thread can get an updated value of the variable.
18. How do threads communicate with each other?
Threads can communicate using three methods i.e., wait(), notify(), and notifyAll().
19. Can two threads execute two methods (static and non-static concurrently)?
Yes, it is possible. If both the threads acquire locks on different objects, then they can execute concurrently without any problem.
20. What is the purpose of the finalize() method?
Finalize() method is basically a method of Object class specially used to perform cleanup operations on unmanaged resources just before garbage collection. It is not at all intended to be called a normal method. After the complete execution of finalize() method, the object gets destroyed automatically.
Multithreading Interview Questions in Java for Experienced
21. What is the synchronization process? Why use it?
Synchronization is basically a process in java that enables a simple strategy for avoiding thread interference and memory consistency errors. This process makes sure that resource will be only used one thread at a time when one thread tries to access a shared resource. It can be achieved in three different ways as given below: 
    • By the synchronized method
    • By synchronized block
    • By static synchronization
Syntax:  
synchronized (object) 
{        
   //statement to be synchronized 
} 
22. What is synchronized method and synchronized block? Which one should be preferred?
Synchronized Method: In this method, the thread acquires a lock on the object when they enter the synchronized method and releases the lock either normally or by throwing an exception when they leave the method.  No other thread can use the whole method unless and until the current thread finishes its execution and release the lock. It can be used when one wants to lock on the entire functionality of a particular method. 

Synchronized Block: In this method, the thread acquires a lock on the object between parentheses after the synchronized keyword, and releases the lock when they leave the block. No other thread can acquire a lock on the locked object unless and until the synchronized block exists. It can be used when one wants to keep other parts of the programs accessible to other threads.
 
Synchronized blocks should be preferred more as it boosts the performance of a particular program. It only locks a certain part of the program (critical section) rather than the entire method and therefore leads to less contention.
23. What is thread starvation?
Thread starvation is basically a situation or condition where a thread won’t be able to have regular access to shared resources and therefore is unable to proceed or make progress. This is because other threads have high priority and occupy the resources for too long. This usually happens with low-priority threads that do not get CPU for its execution to carry on. 

24. What is Livelock? What happens when it occurs?
Similar to deadlock, livelock is also another concurrency problem. In this case, the state of threads changes between one another without making any progress. Threads are not blocked but their execution is stopped due to the unavailability of resources.
25. What is BlockingQueue?
BlockingQueue basically represents a queue that is thread-safe. Producer thread inserts resource/element into the queue using put() method unless it gets full and consumer thread takes resources from the queue using take() method until it gets empty. But if a thread tries to dequeue from an empty queue, then a particular thread will be blocked until some other thread inserts an item into the queue, or if a thread tries to insert an item into a queue that is already full, then a particular thread will be blocked until some threads take away an item from the queue. 

Example: 
package org.arpit.java2blog; 
 
import java.util.concurrent.ArrayBlockingQueue; 
import java.util.concurrent.BlockingQueue; 
 
public class BlockingQueuePCExample { 
 
   public static void main(String[] args) { 
 
       BlockingQueue<String> queue=new ArrayBlockingQueue<>(5); 
       Producer producer=new Producer(queue); 
       Consumer consumer=new Consumer(queue); 
       Thread producerThread = new Thread(producer); 
       Thread consumerThread = new Thread(consumer); 
 
       producerThread.start(); 
       consumerThread.start(); 
 
   } 
 
   static class Producer implements Runnable { 
 
       BlockingQueue<String> queue=null; 
 
       public Producer(BlockingQueue queue) { 
           super(); 
           this.queue = queue; 
       } 
 
       @Override 
       public void run() { 
 
               try { 
                   System.out.println("Producing element 1"); 
                   queue.put("Element 1"); 
                   Thread.sleep(1000); 
                   System.out.println("Producing element 2"); 
                   queue.put("Element 2"); 
                   Thread.sleep(1000); 
                   System.out.println("Producing element 3"); 
                   queue.put("Element 3"); 
               } catch (InterruptedException e) { 
 
                   e.printStackTrace(); 
               } 
       } 
   } 
 
   static class Consumer implements Runnable { 
 
       BlockingQueue<String> queue=null; 
 
       public Consumer(BlockingQueue queue) { 
           super(); 
           this.queue = queue; 
       } 
 
       @Override 
       public void run() { 
 
           while(true) 
           { 
               try { 
                   System.out.println("Consumed "+queue.take()); 
               } catch (InterruptedException e) { 
                   e.printStackTrace(); 
               } 
           } 
       } 
 
   } 
} 
Output: 
Producing element 1 
Consumed Element 1 
Producing element 2 
Consumed Element 2 
Producing element 3 
Consumed Element 3
26. Can you start a thread twice?
No, it's not at all possible to restart a thread once a thread gets started and completes its execution. Thread only runs once and if you try to run it for a second time, then it will throw a runtime exception i.e., java.lang.IllegalThreadStateException. 

Example: 
public class TestThreadTwice1 extends Thread{   
public void run(){   
System.out.println(" thread is executing now........");   
}   
public static void main(String args[]){   
TestThreadTwice1 t1=new TestThreadTwice1();   
t1.start();   
t1.start();   
}   
}   
Output:
thread is executing now........ 
Exception in thread "main" java.lang.IllegalThreadStateException  
27. Explain context switching.
Context switching is basically an important feature of multithreading. It is referred to as switching of CPU from one thread or process to another one. It allows multiple processes to share the same CPU. In context switching, the state of thread or process is stored so that the execution of the thread can be resumed later if required. 
28. What is CyclicBarrier and CountDownLatch?
CyclicBarrier and CountDownLatch, both are required for managing multithreaded programming. But there is some difference between them as given below: 
CyclicBarrier: It is a tool to synchronize threads processing using some algorithm. It enables a set of threads to wait for each other till they reach a common execution point or common barrier points, and then let them further continue execution. One can reuse the same CyclicBarrier even if the barrier is broken by setting it. 
CountDownLatch: It is a tool that enables main threads to wait until mandatory operations are performed and completed by other threads. In simple words, it makes sure that a thread waits until the execution in another thread completes before it starts its execution. One cannot reuse the same CountDownLatch once the count reaches 0. 

29. What do you mean by inter-thread communication?
Inter-thread communication, as the name suggests, is a process or mechanism using which multiple threads can communicate with each other. It is especially used to avoid thread polling in java and can be obtained using wait(), notify(), and notifyAll() methods. 
30. What is Thread Scheduler and Time Slicing?
Thread Scheduler: It is a component of JVM that is used to decide which thread will execute next if multiple threads are waiting to get the chance of execution. By looking at the priority assigned to each thread that is READY, the thread scheduler selects the next run to execute. To schedule the threads, it mainly uses two mechanisms: Preemptive Scheduling and Time slicing scheduling.  

Time Slicing: It is especially used to divide CPU time and allocate them to active threads. In this, each thread will get a predefined slice of time to execute. When the time expires, a particular thread has to wait till other threads get their chances to use their time in a round-robin fashion. Every running thread will get executed for a fixed time period. 
31. What is a shutdown hook?
A shutdown hook is simply a thread that is invoked implicitly before JVM shuts down. It is one of the most important features of JVM because it provides the capacity to do resource cleanup or save application state JVM shuts down.  By calling the halt(int) method of the Runtime class, the shutdown hook can be stopped. Using the following method, one can add a shutdown hook. 
public void addShutdownHook(Thread hook){}     
Runtime r=Runtime.getRuntime();   
r.addShutdownHook(new MyThread());
32. What is busy spinning?
Busy Spinning, also known as Busy-waiting, is a technique in which one thread waits for some condition to happen, without calling wait or sleep methods and releasing the CPU. In this condition, one can pause a thread by making it run an empty loop for a certain time period, and it does not even give CPY control. Therefore, it is used to preserve CPU caches and avoid the cost of rebuilding cache.
33. What is ConcurrentHashMap and Hashtable? In java, why is ConcurrentHashMap considered faster than Hashtable?
ConcurrentHashMap: It was introduced in Java 1.5 to store data using multiple buckets. As the name suggests, it allows concurrent read and writes operations to the map. It only locks a certain portion of the map while doing iteration to provide thread safety so that other readers can still have access to the map without waiting for iteration to complete.  

Hashtable: It is a thread-safe legacy class that was introduced in old versions of java to store key or value pairs using a hash table.  It does not provide any lock-free read, unlike ConcurrentHashMap. It just locks the entire map while doing iteration. 

ConcurrentHashMap and Hashtable, both are thread-safe but ConcurrentHashMap generally avoids read locks and improves performance, unlike Hashtable. ConcurrentHashMap also provides lock-free reads, unlike Hashtable. Therefore, ConcurrentHashMap is considered faster than Hashtable especially when the number of readers is more as compared to the number of writers. 
34. Explain thread priority.
Thread priority simply means that threads with the highest priority will get a chance for execution prior to low-priority threads. One can specify the priority but it's not necessary that the highest priority thread will get executed before the lower-priority thread. Thread scheduler assigns processor to thread on the basis of thread priority. The range of priority changes between 1-10 from lowest priority to highest priority. 

35. What do you mean by the ThreadLocal variable in Java?
ThreadLocal variables are special kinds of variables created and provided by the Java ThreadLocal class. These variables are only allowed to be read and written by the same thread. Two threads cannot be able to see each other’s ThreadLocal variable, so even if they will execute the same code, then there won't be any race condition and the code will be thread-safe.  

Example:  
public class ThreadLocalExp   
{   
     public static class MyRunnable implements Runnable    
   {   
       private ThreadLocal<Integer> threadLocal =   
              new ThreadLocal<Integer>();   
      @Override   
       public void run() {   
           threadLocal.set( (int) (Math.random() * 50D) );   
           try    
           {   
               Thread.sleep(1000);   
           } catch (InterruptedException e) {   
           }   
           System.out.println(threadLocal.get());   
       }   
   }   
   public static void main(String[] args)    
   {   
       MyRunnable runnableInstance = new MyRunnable();    
       Thread t1 = new Thread(runnableInstance);   
       Thread t2 = new Thread(runnableInstance);   
      // this will call run() method    
       t1.start();   
       t2.start();   
   }   
} 
Output: 
10 
33 
10 33 
36. What is semaphore?
Semaphore is regarded as a thread synchronization construct that is usually required to control and manage the access to the shared resource using counters. It simply sets the limit of the thread. The semaphore class is defined within the package java.util.concurrent and can be used to send signals between threads to avoid missed signals or to guard critical sections. It can also be used to implement resource pools or bounded collection.
37. Explain Thread Group. Why should we not use it?
ThreadGroup is a class that is used to create multiple groups of threads in a single object. This group of threads is present in the form of three structures in which every thread group has a parent except the initial thread. Thread groups can contain other thread groups also. A thread is only allowed to have access to information about its own thread group, not other thread groups. 

Previously in the old version of Java, the only functionality that did not work without a thread group was uncaughtException( Thread t, Throwable e). But now in Java 5 versions, there is Thread.setUncaughtExceptionHandler(UncaughtExceptionHandler). So now even that works without thread groups and therefore, there is no need to use thread groups.  
t1.setUncaughtExceptionHandler(new UncaughtExceptionHandler() 
{ 
@Override  
public void uncaughtException(Thread t, Throwable e)  
{  
System.out.println("exception occured:"+e.getMessage()); 
}  
}; 
38. What is the ExecutorService interface?
ExecutorService interface is basically a sub-interface of Executor interface with some additional methods or features that help in managing and controlling the execution of threads. It enables us to execute tasks asynchronously on threads.

Example: 
import java.util.concurrent.ExecutorService;   
import java.util.concurrent.Executors;   
import java.util.concurrent.TimeUnit;   
  
public class TestThread {   
                                   public static void main(final String[] arguments) throws InterruptedException {   
ExecutorService e = Executors.newSingleThreadExecutor();   
 
     try {   
       e.submit(new Thread());   
        System.out.println("Shutdown executor");   
        e.shutdown();   
        e.awaitTermination(5, TimeUnit.SECONDS);   
  } catch (InterruptedException ex) {   
       System.err.println("tasks interrupted");   
  } finally {   
  
        if (!e.isTerminated()) {   
           System.err.println("cancel non-finished tasks");   
     }   
        e.shutdownNow();   
        System.out.println("shutdown finished");   
  }   
  }   
  
  static class Task implements Runnable {   
        
     public void run() {   
          
        try {   
        Long duration = (long) (Math.random() * 20);   
           System.out.println("Running Task!");   
           TimeUnit.SECONDS.sleep(duration);   
     } catch (InterruptedException ex) {   
           ex.printStackTrace();   
     }   
  }   
 }          
}   
Output:
Shutdown executor 
shutdown finished
39. What will happen if we don’t override the thread class run() method?
Nothing will happen as such if we don’t override the run() method. The compiler will not show any error. It will execute the run() method of thread class and we will just don’t get any output because the run() method is with an empty implementation. 

Example:  
class MyThread extends Thread { 
  //don't override run() method 
} 
public class DontOverrideRun { 
  public static void main(String[] args) { 
         System.out.println("Started Main."); 
         MyThread thread1=new MyThread(); 
      thread1.start(); 
         System.out.println("Ended Main."); 
  } 
} 
Output: 
Started Main. 
Ended Main.  
40. What is the lock interface? Why is it better to use a lock interface rather than a synchronized block.?
Lock interface was introduced in Java 1.5 and is generally used as a synchronization mechanism to provide important operations for blocking.  

Advantages of using Lock interface over Synchronization block: 
    • Methods of Lock interface i.e., Lock() and Unlock() can be called in different methods. It is the main advantage of a lock interface over a synchronized block because the synchronized block is fully contained in a single method.  
    • Lock interface is more flexible and makes sure that the longest waiting thread gets a fair chance for execution, unlike the synchronization block.
41. Is it possible to call the run() method directly to start a new thread?
No, it's not possible at all. You need to call the start method to create a new thread otherwise run method won't create a new thread. Instead, it will execute in the current thread.
42. Is it possible that each thread can have its stack in multithreaded programming?
Of course, it is possible. In multithreaded programming, each thread maintains its own separate stack area in memory because of which every thread is independent of each other rather than dependent
                                            		        stream
1. What is the difference between Collection and Stream? (answer)
The main difference between a Collection and a Stream is that Collection contains its elements, but a Stream doesn't. Stream work on a view where elements are actually stored by Collection or array, but unlike other views, any change made on Stream doesn't reflect on the original Collection.

2. What does the map() function do? why you use it? (answer)
The map() function perform map functional operation in Java. This means it can transform one type of object to others by applying a function.

For example, if you have a List of String and you want to convert that to a List of Integer, you can use map() to do so.

Just supply a function to convert String to Integer e.g., parseInt() to map() and it will apply that to all elements of List and give you a List of Integer. In other words, the map can convert one object to another.

If you want to learn more about these new methods introduced in Java S.E. 8, I suggest you take a look at these best Java Programming courses from Udemy and Coursera. One of the most comprehensive courses which cover everything Java developers need to know.



3. What does the filter() method do? when you use it? (answer)
The filter method is used to filter elements that satisfy a certain condition that is specified using a Predicate function.

A predicate function is nothing but a function that takes an Object and returns a boolean. For example, if you have a List of Integer and you want a list of even integers.

In this case, you can use the filter to achieve that. You supply a function to check if a number is even or odd, just like this function, and filter will apply this to stream elements and filter the elements which satisfy the condition and which don't.


4. What does the flatmap() function do? why you need it? (answer)
The flatmap function is an extension of the map function. Apart from transforming one object into another, it can also flatten it.

For example, if you have a list of the list but you want to combine all elements of lists into just one list. In this case, you can use flatMap() for flattening. At the same time, you can also transform an object like you do use map() function.


5. What is the difference between flatMap() and map() functions? (answer)
Even though both map() and flatMap() can be used to transform one object to another by applying a method to each element.

The main difference is that flatMap() can also flatten the Stream. For example, if you have a list of the list, then you can convert it to a big list by using the flatMap() function.

Btw, if you find trouble understanding these functional programming methods like map, flatMap, filter, etc., I suggest you go through From Collections to Streams in Java 8 course on Pluralsight. It's an advanced course but very good.





6. What is the difference between intermediate and terminal operations on Stream? (answer)
The intermediate Stream operation returns another Stream, which means you can further call other methods of Stream class to compose a pipeline.

For example after calling map() or flatMap() you can still call filter() method on Stream.

On the other hand, the terminal operation produces a result other than Streams like a value or a Collection.

Once a terminal method like forEach() or collect() is called, you cannot call any other method of Stream or reuse the Stream.



7. What does the peek() method do? When should you use it? (answer)
The peek() method of Stream class allows you to see through a Stream pipeline. You can peek through each step and print meaningful messages on the console. It's generally used for debugging issues related to lambda expression and Stream processing.


8. What do you mean by saying Stream is lazy? (answer)
When we say Stream is lazy, we mean that most of the methods are defined on Java .util.stream.Stream class is lazy i.e. they will not work by just including them on the Stream pipeline.

They only work when you call a terminal method on the Stream and finish as soon as they find the data they are looking for rather than scanning through the whole set of data.


9. What is a functional interface in Java 8? (answer)
As the name suggests, a functional interface is an interface that represents a function. Technically, an interface with just one abstract method is called a functional interface.

You can also use @FunctionalInterface to annotated a functional interface. In that case, the compiler will verify if the interface actually contains just one abstract method or not. It's like the @Override annotation, which prevents you from accidental errors.

Another useful thing to know is that If a method accepts a functional interface, then you can pass a lambda expression to it.

Some examples of the functional interface are Runnable, Callable, Comparator, and Comparable from old API and Supplier, Consumer, and Predicate, etc. from new function API. You can learn more about those interfaces in Java in these Java 8 online courses. 



10. What is the difference between a normal and functional interface in Java? (answer)
The normal interface in Java can contain any number of abstract methods, while the functional interface can only contain just one abstract method.

You might be thinking why they are called functional interfaces? Once you know the answer, it might be a little easier for you to remember the concept.

Well, they are called functional interfaces because they wrap a function as an interface. The function is represented by the single abstract method on the interface.


11. What is the difference between the findFirst() and findAny() method? (answer)
The findFirst() method will return the first element meeting the criterion i.e. Predicate, while the findAny() method will return any element meeting the criterion, very useful while working with a parallel stream. You can further see this article for a working example of the findFirst() method in Java 8.



12. What is a Predicate interface? (answer) 
A Predicate is a functional interface that represents a function, which takes an Object and returns a boolean. It is used in several Stream methods like filter(), which uses Predicate to filter unwanted elements.

here is how a Predicate function looks like:
public boolean test(T object){
   return boolean; 
}

You can see it just has one test() method which takes an object and returns a boolean. The method is used to test a condition if it passes; it returns true otherwise false.



13. What are Supplier and Consumer Functional interface? (answer) 
The Supplier is a functional interface that returns an object. It's similar to the factory method or new(), which returns an object.

The Supplier has get() functional method, which doesn't take any argument and return an object of type T. This means you can use it anytime you need an object.

Since it is a functional interface, you can also use it as the assignment target for a lambda expression or method reference.

A Consumer is also a functional interface in JDK 8, which represents an operation that accepts a single input argument and returns no result.

Unlike other functional interfaces, Consumer is expected to operate via side-effects. The functional method of Consumer is accept(T t), and because it's a functional interface, you can use it as the assignment target for a lambda expression or method interface in Java 8.


14. Can you convert an array to Stream? How? (answer)
Yes, you can convert an array to Stream in Java. The Stream class provides a factory method to create a Stream from an array, like Stream .of(T ...) which accepts a variable argument, that means you can also pass an array to it as shown in the following example:
String[] languages = {"Java", "Python", "JavaScript"};
Stream numbers = Stream.of(languages);
numbers.forEach(System.out::println);

Output:
Java
Python
JavaScript

So, yes, it's possible to convert an array to Stream in Java 8. You can even convert an ArrayList to Stream, as explained in that article.



15. What is the parallel Stream? How can you get a parallel stream from a List? (answer) 
A parallel stream can parallel execute stream processing tasks. For example, if you have a parallel stream of 1 million orders and you are looking for orders worth more than 1 million, then you can use a filter to do that.

Unlike sequential Stream, the parallel Stream can launch multiple threads to search for those orders on the different parts of the Stream and then combine the result.


Read more: https://www.java67.com/2018/10/java-8-stream-and-functional-programming-interview-questions-answers.html#ixzz7pcPz3moF
1) Predicate: What Is It?
A predefined Functional Interface is a predicate. It can be found in java.util.function. Package of predicate. It only takes one argument, which has the form indicated below.
2) Is the following code flawed in any way? Does it compile or does it produce a specific error?
@FunctionalInterface
public interface Test<A, B, C> 
public C apply(A a, B b);
default void printString() {
System.out.println("softwaretestinghelp");
  }
  }
Yess. Because the code adheres to the functional web api of specifying only one abstract method, it will compile. A default method which does not qualify as an abstract method is the second one, printString().
Related Article: Java Stream Tutorial
3) A Stream API: What Is It? Why is the Stream API necessary?
Java 8 now has a new functionality called Stream API. It is a unique class used for handling items from sources like collections.
The Stream API is necessary for us because
    • Because it offers aggregate operations, processing is made simple.
    • Programming in the functional style is supported.
    • It processes data more quickly. It is therefore suitable for greater performance.
    • Parallel operations are possible.

4) What distinguishes a limit from a skip?
The Stream of the desired size is returned using the limit() method. As an illustration, if you mentioned limit(5), there would be 5 output elements.
5) What function does Java 8's limit() method serve?
The limit of the elements is specified via the Stream.limit() function. Limit(X) will return a stream with the size you specified, where X is the value you entered. It belongs to the class java.util.stream.Stream.
6) What distinguishes Stream's Intermediate and Terminal Operations?
All stream operations fall into one of two categories: Terminal or Intermediate. The operations known as intermediate operations are those that release the stream so that subsequent operations can be performed on it. Lazy operations are intermediate operations since they do not analyze the Stream at the call point.
When a terminal operation is performed, these activities (Intermediate Operations) process data. Map and filter are two examples of intermediate operations.
Processing of Streams is started by Terminal Operations. The Stream runs through all of the Intermediate processes during this call. Sum, Collect, and forEach are some examples of terminal operations.
7) What distinguishes findFirst() from findAny() in the Stream object?
The findAny() method is used to determine any element from the stream, but the findFirst() method is employed to discover the first element from the stream, as the name implies.
While the findAny() is non-deterministic, the findFirst() is predestinarian in nature. Deterministic in programming refers to a system where the outcome is determined by the input or beginning state.
8) The Consumer Functional Interface: What Is It?
Like PredicateT> and FunctionT, R>, Consumer Functional Interface also accepts a single argument. It is categorised as java.util.function. Consumer. This has no value returned.
9) The Supplier Functional Interface: What Is It?
There are no input parameters accepted by the Supplier Functional Interface. It is categorised as java.util.function. Supplier. This uses the get function to return the value.
10) What does Java 8's Nashorn mean?
A Java-based engine for running and analysing JavaScript code is called Nashorn in Java 8.
11) What distinguishes map from flatMap stream operation?
While flatMap Stream delivers zero or more output values per input value, Map gives one output value for every input value.
12) What does Java 8's MetaSpace mean?
A new feature to store classes was added in Java 8. In Java 8, there is a place known as MetaSpace where all the classes are kept. MetaSpace has replaced PermGen. The Java Virtual Machine used PermGen to store the classes prior to Java 7. Java 8 substituted MetaSpace for PermGen because MetaSpace is dynamic and has no size restrictions. It can also grow dynamically.
13) Describe JJS.
JavaScript code is run at the console using JJS, a command-line tool. The new JavaScript engine executable in Java 8 is called JJS.

14) What do Java 8's ChronoUnits do?
The enum ChronoUnits was created to take the place of the Integer values which the former API used to indicate the month, day, etc.
15) What does the Java 8 StringJoiner Class mean? How can we use the StringJoiner Class to join several Strings?
StringJoiner is a new class that was added to the java.util package in Java 8. With the help of this class, we may combine numerous strings that have been separated by delimiters and add prefixes and suffixes to them.
16) What distinguishes a collection from a stream?
A Package includes its elements, whereas a Stream does not, and this is the primary distinction between the two types of data structures. Unlike other views, Stream operates on a view whose elements are actually kept in a collection or array, but any changes made to Stream do not affect the original collection.
17) What distinguishes the map() and flatMap() functions?
Despite the fact that each element can have a function applied to it, map() and flatMap() can both be used to convert one object to another. The primary distinction is that flatMap() can flatten the Stream as well. For instance, you may use the flatMap() function to transform a list of lists into a large list.
18) What distinguishes Stream's intermediate and terminal operations?
You can call additional methods of the Stream class to build a pipeline because the intermediary Stream action returns another Stream.
19) What accomplishes the procedure peek()? When ought one to employ it?
You can peek into a Stream pipeline using the peek() function of the Stream type. Each stage can be peeked through, and the terminal can print out messages that imply something. It is typically used to troubleshoot lambda expressions and stream processing problems.
20) What distinguishes a Java functional interface from a conventional interface?
While the functional interface in Java can only contain one abstract method, the normal interface can include any number of abstract methods. They wrap a function in an interface, which is why they are termed functional interfaces. The one abstract method on the interface serves as the function's representation.
Java Stream Interview Questions For Experienced
1) Predicate interface: what is it?
A function that takes an Object and produces a boolean is represented by a Predicate, which is a functional interface. Several Stream methods, like filter(), which employs Predicate to filter out undesirable components, use it.
2) What exactly does an interface's default method do?
The methods that are declared to use the default keyword are the default methods. Prior to Java 8, it is not possible to define methods inside the interface; however, starting with Java 8, you can do so by utilising default methods. Because it enables you to develop the interface after release, this is also known as the "defender technique." By using the default keyword, you may now introduce new methods without disrupting all the clients. JDK 8 has greatly benefited from this, adding several important methods including for Each() and stream() as default methods to already existing types like Iterable and Collection.
3) What distinguishes Period from Duration in Java 8?
There is a small distinction between Period and Duration, despite the fact that both can be used to compute the distinction between dates in Java. In Java 8, Period is the difference between the two LocalDate values while Length is the difference between the two Instant values. Instead of returning a Duration, the LocalDate till() method returns a Period, which may be used to display a number of days, months, and years that have passed between two dates.
4) What are the main features that JDK has added?
The following are some of the key features that JDK 7 introduced:
    • A better diamond operator type inference.
    • Adding support for strings in switching and case expressions
    • Try-with-resource or automatic resource management
    • Fourth-Join Framework
    • Use an underline in literal numbers
    • Capability of using a single catch block to catch numerous exceptions
    • Binary literals beginning with "0b"
    • The updated File API and Java NIO 2.0
    • G1 Garbage Collectors 
5) What does Java's ForkJoinPool do?
The ForkJoinPool is a unique thread pool that operates on the idea of work-stealing, meaning that if a post is free, it may grab work from the overloaded queue of another thread. As a result, the remedy is more effective.
Related Article: Java Tutorial
6) What does the Java Diamond Operator do?
With Java, the angle bracket was transformed into the diamond operator, which aids in type inference by preventing the need to repeat the type on the right-hand side of the equation. By doing this, programming effort and clutter are minimised without affecting code readability.
7) What are SAM or functional interfaces?
An interface having a single abstract method is referred to as a functional interface. It is also referred to as the Single Abstract Method (SAM) interface as a result. It encapsulates a function as an interface, or, to put it another way, a function is defined by a dependent upon the type method of the interface, which is why it is known as a reference implementation. The amount of static, overridden and default methods in functional interfaces is infinite. Regarding stating Functional Interfaces
8) What is the standard procedure and why is it necessary?
The default method in an interface is a method with a predetermined body. The word default is used. In Java 8, default methods were added for "Backward Compatibility" in the event that the JDK changed any interfaces. All classes that implement the interface will break if a new abstract method is added, and they will all need to implement the new method. The interface conforming classes won't experience any effects from default methods. In the implementation, default methods can indeed be overridden if necessary. Additionally, it is neither synchronised nor final.
9) What do Interfaces' static methods do?
Static methods, that contain method implementation and are accessed using the identity of the interface, are excellent for defining utility methods because they are controlled by the interface and cannot be overridden.
10) What characteristics distinguish a lambda expression?
The two key characteristics of the procedures that are specified as lambda expressions are listed below:
    • Another method may accept lambda expressions as a parameter.
    • Lambda expressions are independent of classes and can be used alone.

11) A type interface: what is it?
Even previous Java versions had a type interface. The method invocation and accompanying declaration are examined by the compiler at compilation time in order to determine the type of argument.
12) What benefits come with using the Optional class?
The following benefits of using the Optionally class are highlighted:
It avoids null tests by encapsulating optional data, such as null or not-null values, resulting in better, more readable, and more reliable code. It serves as an object wrapper and returns an object rather than a value, which can be utilised to prevent run-time errors. NullPointerExceptions
13) What constitutes a Stream's primary elements?
These are the stream's constituents:
    • a source of data
    • a group of intermediary operations to handle the data source
    • a single terminal operation yields the outcome
14) What types of data objects can a stream process and from what sources?
These types of data can be processed by a stream:
    • an assortment of Arrays.
    • an input device or I/O channel.
    • A source that responds such as comments on social media
    • a static factory or a stream generator function.

15) Intermediary operations: what are they?
    • Analyze the stream's components.
    • Usually converts one stream into another
    • Are lazy, that is, they wait to execute until a terminal action is called.
    • Carries out internal iteration on each component of the source.
    • The processing pipeline allows for the chaining of any number of activities.
    • The operations are carried out in the prescribed order.
    • Lambda functions predominate in intermediate processes.
Most Common Java Stream FAQs
1) What new features does Java 8 have?
The following is a list of the additional features that are included in Java 8:
    • References to Methods
    • Lambda Expressions
    • Default methods 
    • Optional Class
    • Functional Interface
    • JavaScript Engine Nashorn
    • Stream API
    • Date API
2) Functional Interfaces: What Are They?
An interface that just has one abstract method is said to be functional. These interfaces are implemented using a Lambda Expression, therefore in order to utilise it, you must either develop a new task to implement or use an existing functional interface from Java 8.
3) What is an elective course?
Java 8 introduced the optional class, a special wrapping class designed to prevent NullPointerExceptions. This last class can be found in the java.util package. When we don't do the Null checks, NullPointerExceptions happen.
4) What are the standard techniques?
The interface's default methods are those with a body. These techniques make use of the default keywords, as their name suggests. These default methods are used for "Backward Compatibility," which implies that if the JDK alters any interface (without a default method), the classes that implement that interface would stop working. On the other side, you can offer the default implementation if you add the defaults method to an interface. The implementing classes won't be impacted by this.
5) What are the Lambda Function's primary characteristics?
The following are the primary properties of the lambda function:
    • It is possible to pass a lambda expression method as an argument to another method.
    • A method does not need to be a member of a class to exist.
    • Since the compiler can determine the type from the parameter's value, there is no need to declare the type of the parameter.
    • When utilising numerous parameters, parentheses can be used, however when using a single parameter, they are not necessary.
    • There is little need for curly braces if the expression body only contains one sentence.
6) Why was the previous date and time flawed?
The disadvantages of the previous date and time are outlined below:
Java.util.
    • The new Java 8 Date and Time API is thread-safe, whereas Date is changeable and not thread-safe.
    • While the previous date and time are badly conceived, Java 8's Date and Time API complies with ISO standards.
    • It has added a number of date-related API classes, like LocalDate, LocalTime, LocalDateTime, etc.
    • When comparing the two in terms of performance, Java 8 performs better than the previous date and time system.
Related Article: Java Interview Questions
7) How is a functional interface made?
Java can recognise a functional interface, but you can define one by using an annotation.
@FunctionalInterface
There can only be one abstract method once the functional interface has been specified. You can create numerous dynamic methods and default methods because there is only one abstract method.
8) SAM interference: What is it?
FunctionalInterface, a new feature introduced in Java 8, can only have one abstract method. These interfaces are commonly referred to as SAM Interfaces because they only specify one abstract method. The abbreviation "Single Abstract Method" is SAM.
9) How does Method Reference work?
Method Reference is a new feature that was added to Java 8. This phrase is used to describe the functional interface method. When referring to a method, it can take the place of a lambda expression.
10) Describe the ensuing Syntax
String:: ValueOfExpression
It is a reference for the String class' ValueOf method. System.out:: println is a main stage that refers to the println method of the System class's out object. It provides back the provided argument's appropriate string representation. The case may be C.

1)what is the need for oops?
2)what are the main features of oops?
3)what is inheritance
4)what is Encapsulation
5)what is polymorphism
6)what is Abstraction
7) what is method
8) what is constructor
9)what are some advantages of using oops
10)why is oops so popular?
11)what is class
12)what is an object
13)what is copy constructor
14)Are there any limitations of interface
15)what  are the various types of inheritance
16)what is single inheritance 
17)multiple inheritances
18)Multi-level inheritance 
19)Hiearchical inheritance
20)Hybrid inheritance
1)what is classloader
2)what are the memory allocations available in java
3)will the program run if i write static public void main
4)what is default value stoerd in local variable
5)what is the output of the following code segment
6)what is an association
7)define copy constructor in java
8)what is a marker interface 
9)what is object cloning
10)
11)1)what is collection in java
2)what is ArrayList in java
3)what is LinkedList in java
4)Difference between ArrayList and LinkedList
5)what is ListInterface in java
6)what is vector in java
7)Diffenerence between Vector and ArrayList
8)what is Map
9)what is stack
10)Difference between List and Stack
11)Difference between List and Queue
12)Difference between Map and List
13)Difference between set and list
14)what is HashMap
15)what is tree
16)what is Hashset
17)list set queue map
18)what is queue
19) Difference between map and queue
20)Difference between array and arrayList

what is multithreading
multithreading using Runnable interface
multithreading using Lambda expresion
multithreading join and isAlive method
multithread priority
multithread synchronized keyword
multithread interThread communication
									-: Assignment 1 :-
1)Can you use abstract and final both with a method ?
ans :- An abstract keyword cannot be used with variables and constructors. if a class is abstract, it cannot be instantiated.if a method is abstract, it does not  contain the body . we can not use abstract keyword with the final
:-An abstract keyword cannot be used with variables and constructors.
:-if a class is abstract,it cannot be instantiated.
:-if a method id abstract,it does not contain the body.
:-we can not use the abstract keyword with the final.
:-we cannot declare adstract methods as private.
:-we cannot declare abstract method as static.
:-An abstract method cannot be synchronized.
2)Can we execute a program without main()method?
ans :- A program that does not have the main()method gives an error at run time . So the main()method should always be written as : public static void main(String args[])
3) Difference Between the Constructor and method 
ans :- 
Constructor :-						 Method :-
it is mainly used for initializing the object.    :-it is mainly used to reuse the code without writing							the code again.
it is implicitly invoked by the system.		  :-A Method is called by the programmer.
sub-class can not inherit parent class 		  :-Sub-class can inherit method of the parent 	constructor.					  	class.
it has no return type.it can or cannot return 	  :-so ,it has a return type.
any value to the caller.
4)Can we override the private methods
ans :- if we assign a private modifier to any method to any method or variable, that method or variable can be overridden to sub-class using all type of access modifiers.
5)Difference Between the constructor and the method in java
Constructor:-                                            Method:-
 :- The new keyword plays an important role             :-Method calls are responside for 
in invoking the constructor.				 invoking methods.
:-it has no return type .it can or cannot return any     :- So, it has a return type.
value to the caller.
:- The constructor name will always be the class name.   :-We can use any name for the method as 								  addRow,addNum and subNumbers etc.
:-A class can have more than one parameterized		:-A class can also have more than one 
constructor.But constructors should have different       method with the same name but parameters.						different in  arguments and datatypes.
:-sub-class cannot inherit parent class constructor.	:-Sub-class can inherit the method of 								the parent class.
6) Difference between  method overloading method overriding in java
ans:- Method overloading 			method overriding
:-Method overloading is used to increase the   :-Method overriding is used to provide the  readability of the program.			specific implementation of the method that is   						already provided by its super class. 
:-Method overloading is overloading is the      :-method overriding is the example of run
example of compile time polymorphism .    	 time polymorphism.
7) Can we make constructors static ?
ans :- a constructor is not allowed to be abstract, final,static native ,or strictfp.so ,there is no static constructor in java.
:- A static constructor used to initialize static data means the specified task will execute only
one throughout the program.
It will not take parameters or access modifiers.
A specific class can have only one static constructor.
It does not allow inheritance or overloading.
It is invoked automatically, can not be called directly or explicitly.
If the value of static fields is not initialized, it will initialize to default values.
8) Can we override a static method ?
ans:- No,we cannot override static method  because method overriding is based on dynamic
binding at runtime and the static  methods are bonded static binding at compiletime.
So,we cannot override static methods.
or
No, we cannot override static methods because method overriding is based on dynamic binding at runtime and the static methods are bonded using static binding at compile time. So, we cannot override static methods.

The calling of method depends upon the type of object that calls the static method.
9)Difference between abstract class and interface 
ans:- Abstract class 				Interface
:-Abstract class can have abstract and non	interface can have only abstract methods. since  							java 8 ,it can have default and static methods -abstract methods.				also.
:-Absttract class does not support multiple     interface supports multiple inheritance.
inheritance.
:-Abstract class can provite the  implementation Interface cannot provide the implementation of
of interface.					  the implementation of abstract class.
:-The abstract keyword is uded to declare	 An interface can extend another java interface  abstract class.							only.
:-An abstract class can be extended using    An interface can be implemented using keyword 
keyword "extends"						"implements".
:- A Java abstract class can have class 
members like private, protected, etc.         Members of a Java interface are public by default.
10)what is Marker Interface?
ans :-  we will discuss about marker interface in Java, its uses, built-in (Serializable, Cloneable, and Remote Interfaces) and custom marker interface
or
An interface that does not contain methods, fields, and constants is known as marker interface. In other words, an empty interface is known as marker interface or tag interface. It delivers the run-time type information about an object. It is the reason that the JVM and compiler have additional information about an object. The Serializable and Cloneable interfaces are the example of marker interface. In short, it indicates a signal or command to the JVM.
or
It is an empty interface (no field or methods). Examples of marker interface are Serializable, Cloneable and Remote interface. All these interfaces are empty interfaces. 
11)Can we abstract class in java that has main method?
ans:- Yes, you can use the main() method in abstract class. The main() method is a static method so it is associated with Class, not with object or instance.
12) what is abstract class
ans:-An abstract class in Java is one that is declared with the abstract keyword. It may have both abstract and non-abstract methods(methods with bodies). An abstract is a java modifier applicable for classes and methods in java but not for Variables. 
13)Execution sequence for static block, block, constructor and method.
ans:- static block:-
A static block is a block of code with a static keyword. In general, these are used to initialize the static members of a class. JVM executes static blocks before the main method at the time loading a class.
Example
public class MyClass {
   static{
      System.out.println("Hello this is a static block");
   }
   public static void main(String args[]){
      System.out.println("This is main method");
   }
}
constructor:-
A constructor is similar to method and it is invoked at the time creating an object of the class, it is generally used to initialize the instance variables of a class. The constructors have same name as their class and, have no return type.
Example
public class MyClass {
   MyClass(){
      System.out.println("Hello this is a constructor");
   }
   public static void main(String args[]){
      new MyClass();
   }
}
14)Is Multiple inheritance supported in Java ? Why ?
ans:-The Java programming language supports multiple inheritance of type, which is the ability of a class to implement more than one interface.
or
Note: Java doesn’t support Multiple Inheritance
15)Can we declare main method as final ?
ans:-Yes, we can declare the main () method as final in Java. The compiler does not throw any error. If we declare any method as final by placing the final keyword then that method becomes the final method. 
or
Yes, we can declare the main () method as final in Java. The compiler does not throw any error.

If we declare any method as final by placing the final keyword then that method becomes the final method.
The main use of the final method in Java is they are not overridden.
We can not override final methods in subclasses.
16)How to prevent inheritance and method overriding in java?
ans:-
17)explain oops concepts with real time example in java
ans:-Object-oriented programming (OOP) in Java is a programming methodology or paradigm (model)  to design a computer program using classes and objects.
It is the most popular programming paradigm and widely used in the software industry today. It is an extension of procedural programming.
18)Can we declare a constructor as final ?
ans:-
Yes, we can declare the main () method as final in Java. The compiler does not throw any error. If we declare any method as final by placing the final keyword then that method becomes the final method. The main use of the final method in Java is they are not overridden.
19)Can we declare an interface as final ?
ans:-No ;Interface only have abstract methods. methods. interface method can not be final . cannot be declared final.
20)Distinguish between static loading and dynamic class loading ?
ans:-The major difference between static and dynamic class loading is that in static loading retrieval of class definition and instantiation of the object is done at compile time, while in dynamic loading classes are loaded at run time using Class.
21)what is constructore in java
ans:-A constructor in Java is similar to a method that is invoked when an object of the class is created.
constructor is a similar to a method.constructor is same name of the class name and deffirent parameter and argument.
22)what is  abstract keyword
ans:- abstract is a non-access modifier in java applicable for classes, methods but not variables. It is used to achieve abstraction which is one of the pillar of Object Oriented Programming(OOP).
The abstract keyword is a non-access modifier, used for classes and methods.
Class: An abstract class is a restricted class that cannot be used to create objects (to access it, it must be inherited from another class).
Method: An abstract method can only be used in an abstract class, and it does not have a body. The body is provided by the subclass (inherited from).
23)

									-: Assignment 1 :-
1)Can you use abstract and final both with a method ?
ans :- An abstract keyword cannot be used with variables and constructors. if a class is abstract, it cannot be instantiated.if a method is abstract, it does not  contain the body . we can not use abstract keyword with the final
:-An abstract keyword cannot be used with variables and constructors.
:-if a class is abstract,it cannot be instantiated.
:-if a method id abstract,it does not contain the body.
:-we can not use the abstract keyword with the final.
:-we cannot declare adstract methods as private.
:-we cannot declare abstract method as static.
:-An abstract method cannot be synchronized.
2)Can we execute a program without main()method?
ans :- A program that does not have the main()method gives an error at run time . So the main()method should always be written as : public static void main(String args[])
3) Difference Between the Constructor and method 
ans :- 
Constructor :-						 Method :-
it is mainly used for initializing the object.    :-it is mainly used to reuse the code without writing							the code again.
it is implicitly invoked by the system.		  :-A Method is called by the programmer.
sub-class can not inherit parent class 		  :-Sub-class can inherit method of the parent 	constructor.					  	class.
it has no return type.it can or cannot return 	  :-so ,it has a return type.
any value to the caller.
4)Can we override the private methods
ans :- if we assign a private modifier to any method to any method or variable, that method or variable can be overridden to sub-class using all type of access modifiers.
5)Difference Between the constructor and the method in java
Constructor:-                                            Method:-
 :- The new keyword plays an important role             :-Method calls are responside for 
in invoking the constructor.				 invoking methods.
:-it has no return type .it can or cannot return any     :- So, it has a return type.
value to the caller.
:- The constructor name will always be the class name.   :-We can use any name for the method as 								  addRow,addNum and subNumbers etc.
:-A class can have more than one parameterized		:-A class can also have more than one 
constructor.But constructors should have different       method with the same name but parameters.						different in  arguments and datatypes.
:-sub-class cannot inherit parent class constructor.	:-Sub-class can inherit the method of 								the parent class.
6) Difference between  method overloading method overriding in java
ans:- Method overloading 			method overriding
:-Method overloading is used to increase the   :-Method overriding is used to provide the  readability of the program.			specific implementation of the method that is   						already provided by its super class. 
:-Method overloading is overloading is the      :-method overriding is the example of run
example of compile time polymorphism .    	 time polymorphism.
7) Can we make constructors static ?
ans :- a constructor is not allowed to be abstract, final,static native ,or strictfp.so ,there is no static constructor in java.
:- A static constructor used to initialize static data means the specified task will execute only
one throughout the program.
It will not take parameters or access modifiers.
A specific class can have only one static constructor.
It does not allow inheritance or overloading.
It is invoked automatically, can not be called directly or explicitly.
If the value of static fields is not initialized, it will initialize to default values.
8) Can we override a static method ?
ans:- No,we cannot override static method  because method overriding is based on dynamic
binding at runtime and the static  methods are bonded static binding at compiletime.
So,we cannot override static methods.
or
No, we cannot override static methods because method overriding is based on dynamic binding at runtime and the static methods are bonded using static binding at compile time. So, we cannot override static methods.

The calling of method depends upon the type of object that calls the static method.
9)Difference between abstract class and interface 
ans:- Abstract class 				Interface
:-Abstract class can have abstract and non	interface can have only abstract methods. since  							java 8 ,it can have default and static methods -abstract methods.				also.
:-Absttract class does not support multiple     interface supports multiple inheritance.
inheritance.
:-Abstract class can provite the  implementation Interface cannot provide the implementation of
of interface.					  the implementation of abstract class.
:-The abstract keyword is uded to declare	 An interface can extend another java interface  abstract class.							only.
:-An abstract class can be extended using    An interface can be implemented using keyword 
keyword "extends"						"implements".
:- A Java abstract class can have class 
members like private, protected, etc.         Members of a Java interface are public by default.
10)what is Marker Interface?
ans :-  we will discuss about marker interface in Java, its uses, built-in (Serializable, Cloneable, and Remote Interfaces) and custom marker interface
or
An interface that does not contain methods, fields, and constants is known as marker interface. In other words, an empty interface is known as marker interface or tag interface. It delivers the run-time type information about an object. It is the reason that the JVM and compiler have additional information about an object. The Serializable and Cloneable interfaces are the example of marker interface. In short, it indicates a signal or command to the JVM.
or
It is an empty interface (no field or methods). Examples of marker interface are Serializable, Cloneable and Remote interface. All these interfaces are empty interfaces. 
11)Can we abstract class in java that has main method?
ans:- Yes, you can use the main() method in abstract class. The main() method is a static method so it is associated with Class, not with object or instance.
12) what is abstract class
ans:-An abstract class in Java is one that is declared with the abstract keyword. It may have both abstract and non-abstract methods(methods with bodies). An abstract is a java modifier applicable for classes and methods in java but not for Variables. 
13)Execution sequence for static block, block, constructor and method.
ans:- static block:-
A static block is a block of code with a static keyword. In general, these are used to initialize the static members of a class. JVM executes static blocks before the main method at the time loading a class.
Example
public class MyClass {
   static{
      System.out.println("Hello this is a static block");
   }
   public static void main(String args[]){
      System.out.println("This is main method");
   }
}
constructor:-
A constructor is similar to method and it is invoked at the time creating an object of the class, it is generally used to initialize the instance variables of a class. The constructors have same name as their class and, have no return type.
Example
public class MyClass {
   MyClass(){
      System.out.println("Hello this is a constructor");
   }
   public static void main(String args[]){
      new MyClass();
   }
}
14)Is Multiple inheritance supported in Java ? Why ?
ans:-The Java programming language supports multiple inheritance of type, which is the ability of a class to implement more than one interface.
or
Note: Java doesn’t support Multiple Inheritance
15)Can we declare main method as final ?
ans:-Yes, we can declare the main () method as final in Java. The compiler does not throw any error. If we declare any method as final by placing the final keyword then that method becomes the final method. 
or
Yes, we can declare the main () method as final in Java. The compiler does not throw any error.

If we declare any method as final by placing the final keyword then that method becomes the final method.
The main use of the final method in Java is they are not overridden.
We can not override final methods in subclasses.
16)How to prevent inheritance and method overriding in java?
ans:-
17)explain oops concepts with real time example in java
ans:-Object-oriented programming (OOP) in Java is a programming methodology or paradigm (model)  to design a computer program using classes and objects.
It is the most popular programming paradigm and widely used in the software industry today. It is an extension of procedural programming.
18)Can we declare a constructor as final ?
ans:-
Yes, we can declare the main () method as final in Java. The compiler does not throw any error. If we declare any method as final by placing the final keyword then that method becomes the final method. The main use of the final method in Java is they are not overridden.
19)Can we declare an interface as final ?
ans:-No ;Interface only have abstract methods. methods. interface method can not be final . cannot be declared final.
20)Distinguish between static loading and dynamic class loading ?
ans:-The major difference between static and dynamic class loading is that in static loading retrieval of class definition and instantiation of the object is done at compile time, while in dynamic loading classes are loaded at run time using Class.
21)what is constructore in java
ans:-A constructor in Java is similar to a method that is invoked when an object of the class is created.
constructor is a similar to a method.constructor is same name of the class name and deffirent parameter and argument.
22)what is  abstract keyword
ans:- abstract is a non-access modifier in java applicable for classes, methods but not variables. It is used to achieve abstraction which is one of the pillar of Object Oriented Programming(OOP).
The abstract keyword is a non-access modifier, used for classes and methods.
Class: An abstract class is a restricted class that cannot be used to create objects (to access it, it must be inherited from another class).
Method: An abstract method can only be used in an abstract class, and it does not have a body. The body is provided by the subclass (inherited from).
23)

1) Create a branch   from master/main 
2) add change to master 
3)create a pull request with appropriate command 
4) merge the pull request
Assignment: Memory Management in Java 
Focus:  where variables are created & scope of various types of variables( e.g method local, static , etc )
1) study the methods of Object class

Assignment : (First priority task)
write  Add method  using generics to add any type ( note: for string ,char you can just concatenate)
1) what is generic in java?
2) what is generic class in java?
3) what is Generic type
4)what is Generic method
5)Bounded Type Parameters
6)Advantages Of Java Generics
#1) Type Safety
#2) Code Reusability
#3) No Need For Typecasting
#4) Implement Generic Algorithms
#5) Compile-Time Checking
Q #1) Why do we use Generics in Java?
Q #2) Are Generics important in Java?
Q #3) When did Java add Generics?
Q #4) What is a Generic type?
Q #5) Can we use Generics with Array in Java?
Assignment: Memory Management in Java 
Garbage Collector:-
Program counter (PC) registers:-
1)Can you use abstract and final both with a method ?
2)Can we execute a program without main()method?
3) Difference Between the Constructor and method 
4)Can we override the private methods
6) Difference between  method overloading method overriding in java
7) Can we make constructors static ?
8) Can we override a static method ?
9)Difference between abstract class and interface
10)what is Marker Interface?
11)Can we abstract class in java that has main method?
12) what is abstract class
13)Execution sequence for static block, block, constructor and method.
14)Is Multiple inheritance supported in Java ? Why ?
15)Can we declare main method as final ?
16)How to prevent inheritance and method overriding in java?
17)explain oops concepts with real time example in java
18)Can we declare a constructor as final ?
19)Can we declare an interface as final ?
20)Distinguish between static loading and dynamic class loading ?
21)what is constructore in java
22)what is  abstract keyword
Create and use while loops
Create and use for loops, including the enhanced for loop
Create and use do-while loops 
Compare loop constructs
Use break and continue
Working with methods and encapsulation
Create methods with arguments and return values, including overloaded methods 
Apply the static keyword to methods and fields 
Create and overload constructors, including impact on default constructors 
Apply access modifiers
Apply encapsulation principles to a class
Determine the effect on object references and primitive values when they are passed 
into methods that change the values
1) Iterating streams 
2) Max,Min, in streams
3)Distinct and Collector
4)Filtering and ttransformations 
5)Grouping data with streams
6)Reduce and flatmap 
7)Joining strings
Define the scope of variables 
Define the structure of a Java class
Create executable Java applications with a main method; run a Java program from 
the command line, including console output
Import other Java packages to make them accessible in your code
Compare and contrast the features and components of Java, such as platform inde- 
pendence, object orientation, encapsulation, and so on
Working with Java data types
Declare and initialize variables (including casting of primitive data types) 
Differentiate between object reference variables and primitive variables 
Know how to read and write to object fields
Explain an object's lifecycle (creation, "dereference by reassignment," and garbage 
collection)
Develop code that uses wrapper classes such as Boolean, Double, and Integer 
Using 0perators and decision constructs
Use Java operators, including parentheses to override operator precedence 
Test equality between Strings and other objects using == and equals() 
Create if and if/else and ternary constructs
Use a switch statement
Assignment: Study  Comparator,Comparable and its methods and show 2 examples each.
Assignment: Study Top 20 Generics interview questions and answer with code.
1)generic



java 8 feature
1)Interface & Abstract class

1) Consumer 
2) Biconsumer 
3) Predicate 
4) Bipredicate 
5) Consumer chaining 
6) PredicateChaining 
7) BipredicateWithBiconsumer
8) Function  ( new ) 
9) Supplier  (new )
2)Functional interface
3)Lambda
4)inbuld functional interface
5)constructor (Super keyword)
Exception handling 
try catch
throw
throws
Exception hierarchy
what isdifference checked and unchecked exception
what is runtime exception
what is compile time exception
finally
stream
and function
lambda scop 
[12:12, 07/12/2022] Promod Giit: 1) Write 5 switch class examples 
2) Difference between String , StringBuilder & StringBuffer 
3) Study equals and hashcode methods of the Object class 
4) difference between == and equals
[12:13, 07/12/2022] Promod Giit: 5) Write 5 switch class examples
